Aether Language Standard

= Core Syntax =
• Control termination: 'end' for blocks
• 0-based array indexing
• Semicolon optional for expression statements

= Typing =
• Dynamic typing by default
• Optional type annotations:
  local x: number = 5
  function(a: string): boolean end

= Variables =
• Mutable variables:
  local x = 10
  x = 20
  
• Constants:
  local const MAX = 100
  const GLOBAL_CONST = true

= Control Flow =
• Conditional:
  if condition then
  elseif condition then
  else
  end

• Loops:
  while condition do ... end
  repeat ... until condition
  for i=start,stop,step do ... end
  for k,v in pairs(t) do ... end

• Jump statements:
  break
  goto label
  ::label::

= Functions =
• Declaration styles:
  function name() ... end
  local function fn() ... end
  local fn = function() ... end
  async function fetch() ... end  -- Async function syntax

• First-class features:
  - Assign to variables: local f = function() end
  - Pass as arguments: map(numbers, function(n) return n*2 end)
  - Return from functions: function makeCounter() return function() ... end end
  - Store in data structures: operations = {add = function(a,b) return a+b end}

• Features:
  - Varargs: function(...) end
  - Named parameters: function({x,y}) end
  - Method calls: obj:method()
  - Closures with lexical scoping

= Error Handling =
• Try/catch/finally:
  try
    -- code
  catch err
    -- handle error
  finally
    -- cleanup
  end

= Operators =
• Arithmetic: + - * / // % ^
• Bitwise: & | ~ << >>
• Logical: and or not
• Comparison: == ~= < > <= >=
• Assignment: = += -= *= /= //= %= ??=
• Special:
  - Null coalescing: ??
  - Safe navigation: ?. ?[]
  - Pipe: |>
  - Typeof: typeof(x)
  - Type assertion: value as type

= Types =
• Primitive: number, string, boolean, nil, void, any, unknown
• Complex:
  - Arrays: number[]
  - Functions: function(number): string
  - Tables: table<string, number>
• User-defined types:
  type Point = {x: number, y: number}

= Data Structures =
• Tables:
  {key = value, [1] = "item"}
  {__metatable = meta}
  
• Arrays:
  [1, 2, 3]
  [: sparse array syntax]

= Metaprogramming =
• Metatables:
  {__add = function(a,b) ... end}
• Metamethods:
  __add, __sub, __mul, __div, __mod, __pow,
  __unm, __concat, __len, __eq, __lt, __le,
  __tostring, __pairs, __ipairs, __call

= Concurrency =
• Async functions:
  async function fetchData()
    return await http_get("url")
  end

• Coroutine spawn:
  spawn function()
    -- coroutine body
  end

= Pattern Matching =
• Match expression:
  match value with
    pattern => expression
    {x,y} when x>0 => expression
  end

= Experimental Features =
• Decorators:
  @serializable
  @validate_params({max: 100})
  function save_record(record) end

• Increment shortcuts:
  counter +_  -- equivalent to counter += 1
  index -_    -- equivalent to index -= 1

• Non-null assertion:
  value = maybe_null!!

= Type System =
• Type declarations:
  type Person = {
    name: string,
    age: number
  }
  
• Function types:
  type Mapper = function(number): string

= Special Syntax =
• String literals: "double" or 'single' quotes
• Number formats: 123, 123.45, 1e5
• Table shorthand:
  {x, y} -- equivalent to {x = x, y = y}

• Async functions:
  local fetch = async function()
    return await http_get("url")
  end

• Pipe operator: 
  result = data |> process() |> format()

• Type checking:
  type_name = typeof(value)
  casted = value as number

• Safe navigation:
  obj?.property
  arr?[index]

• Null coalescing:
  name = username ?? "Anonymous"

= Modules =
• Import system:
  import { Component } from "ui.lib" as UI
  import * as Math from "math"

= Code Organization =
• Blocks: Indentation-insensitive
• Line continuation: Implicit through operators
• Max line length: 80 characters recommended